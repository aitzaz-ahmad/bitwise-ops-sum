// question1.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
using namespace std;


int add(int a, int b)
{
	/*
	The bitwise XOR provides the functionality of a half adder, and
	disregards the carry bit generated against the sum. By XORing two
	bit we can generate their bitwise sum. However, this sum does not
	account for the carry that might have been generated. In order to
	factor in the carry generated for the sum, we need to check the 
	bitwise AND of these bits.

	The bitwise AND, unfortunately, only tells us whether or not a 
	carry was generated against the sum of the bits being added. In
	order to incorporate the generated carry to the sum of the two 
	bits, we would have to shift left the carry bit and add the 
	resultant to the bitwise sum using the XOR operation. This would
	yield the result as that of a full adder.

	After performing this operation, however, we need to recheck if 
	yet another carry was generated. In case of another carry, we
	would need to repeat the entire process again until the addition 
	stops producing a carry.

	The example below illustrates the working of the algorithm explained
	above.

	Let:
		a = 3, b = 1

		The binary representation of both the numbers is as follows. 
		Please note that for the sake of simplicity the example below
		uses 8 bits to denote the binary representation of each integer.

		a --> 0000 0011
		b --> 0000 0001

		carry = a AND b --> 0000 0001 (carry generated by adding the LSBs)
		sum   = a XOR b	-->	0000 0010 (bitwise sum)
		
		since carry > 0, LEFT_SHIFT carry by 1 and add the resultant to the sum
		b = carry << 1	--> 0000 0010
		carry = sum AND b --> 0000 0010 (carry generated by adding bits
		sum   = sum XOR b --> 0000 0000 (bitwise sum)

		since carry > 0,  LEFT_SHIFT carry by 1 and add the resultant to the sum
		b = carry << 1	--> 0000 0100
		carry = sum AND b --> 0000 0000 (no carry)
		sum   = sum XOR b --> 0000 0100 (biwise sum)

		since carry == 0, sum now contains the final result of a + b
		sum --> 0000 0100 (binary)

		The binary notation above of the value stored in sum corresponds to 
		the value 4 in decimal notation, which is the sum of 3 + 1.
	*/

	// Proceed to execute the logic of adding the two numbers only if b is
	// non-zero. If b is zero, the sum would be the same as a.
	while (b)
	{
		// perform a bitwise AND to produce the carry (if any) and SHIFT_LEFT the
		// resultant by 1 for the next iteration...
		int carry = (a & b) << 1;

		// generate the bitwise sum of the two numbers and store the sum in a...
		a = a ^ b;

		// assign the carry to b to be factored in during the next iteration...
		b = carry;
	}

	return a;
}

int main(int argc, char* argv[])
{
	int a = 2011;
	int b = 8;

	if (argc == 3)
	{
		a = atoi(argv[0]);
		b = atoi(argv[1]);
	}

	cout << "a:\t" << a << endl;
	cout << "b:\t" << b << endl;
	cout << "sum :\t" << add(a, b) << endl;

	return 0;
}
